import java.util.*;
import java.util.function.Function;
import java.math.BigDecimal;

public class Main {

    // ---- ExpressionEvaluator como classe estática interna ----
    static class ExpressionEvaluator {
        private static final Map<String, Function<Double, Double>> FUNCOES = new HashMap<>();
        private static final Map<String, Integer> PRECEDENCIA = new HashMap<>();
        private static final Set<String> OPERADORES = new HashSet<>(Arrays.asList("+", "-", "*", "/", "^"));

        static {
            FUNCOES.put("sin", Math::sin);
            FUNCOES.put("cos", Math::cos);
            FUNCOES.put("tan", Math::tan);
            FUNCOES.put("exp", Math::exp);
            FUNCOES.put("log", Math::log);
            FUNCOES.put("sqrt", Math::sqrt);
            FUNCOES.put("abs", Math::abs);

            PRECEDENCIA.put("+", 1);
            PRECEDENCIA.put("-", 1);
            PRECEDENCIA.put("*", 2);
            PRECEDENCIA.put("/", 2);
            PRECEDENCIA.put("^", 3); // potência é associativa à direita
        }

        public static double avaliar(String expressao, double x) {
            String xStr = formatNumber(x);
            expressao = expressao.toLowerCase().replace("x", "(" + xStr + ")");
            expressao = expressao.replaceAll("\\s+", "");
            List<String> tokens = tokenizar(expressao);
            List<String> rpn = converterParaRPN(tokens);
            return avaliarRPN(rpn);
        }

        private static String formatNumber(double num) {
            // evita notação científica
            return new BigDecimal(Double.toString(num)).stripTrailingZeros().toPlainString();
        }

        private static List<String> tokenizar(String expr) {
            List<String> tokens = new ArrayList<>();
            StringBuilder numero = new StringBuilder();
            for (int i = 0; i < expr.length(); i++) {
                char c = expr.charAt(i);
                if (Character.isDigit(c) || c == '.') {
                    numero.append(c);
                } else {
                    if (numero.length() > 0) {
                        tokens.add(numero.toString());
                        numero.setLength(0);
                    }
                    if (Character.isLetter(c)) {
                        StringBuilder func = new StringBuilder();
                        while (i < expr.length() && Character.isLetter(expr.charAt(i))) {
                            func.append(expr.charAt(i));
                            i++;
                        }
                        i--;
                        tokens.add(func.toString());
                    } else if ("+-*/^()".indexOf(c) >= 0) {
                        tokens.add(String.valueOf(c));
                    } else {
                        // ignora outros (ex.: espaços já removidos)
                    }
                }
            }
            if (numero.length() > 0) tokens.add(numero.toString());
            return tokens;
        }

        private static List<String> converterParaRPN(List<String> tokens) {
            List<String> saida = new ArrayList<>();
            Deque<String> pilha = new ArrayDeque<>();

            for (int i = 0; i < tokens.size(); i++) {
                String t = tokens.get(i);
                if (ehNumero(t)) {
                    saida.add(t);
                } else if (FUNCOES.containsKey(t)) {
                    pilha.push(t);
                } else if (OPERADORES.contains(t)) {
                    // detectar unário '-'
                    if (t.equals("-") && (i == 0 || tokens.get(i - 1).equals("(") || OPERADORES.contains(tokens.get(i - 1)))) {
                        // transforma unário em (0 <valor>) usando 0 antes
                        saida.add("0");
                    }
                    while (!pilha.isEmpty() && OPERADORES.contains(pilha.peek())) {
                        String opTopo = pilha.peek();
                        if ((ehEsquerdaAssociativo(t) && PRECEDENCIA.get(t) <= PRECEDENCIA.get(opTopo))
                                || (!ehEsquerdaAssociativo(t) && PRECEDENCIA.get(t) < PRECEDENCIA.get(opTopo))) {
                            saida.add(pilha.pop());
                        } else break;
                    }
                    pilha.push(t);
                } else if (t.equals("(")) {
                    pilha.push(t);
                } else if (t.equals(")")) {
                    while (!pilha.isEmpty() && !pilha.peek().equals("(")) {
                        saida.add(pilha.pop());
                    }
                    if (pilha.isEmpty()) throw new IllegalArgumentException("Parênteses desbalanceados");
                    pilha.pop(); // remove "("
                    if (!pilha.isEmpty() && FUNCOES.containsKey(pilha.peek())) {
                        saida.add(pilha.pop());
                    }
                } else {
                    throw new IllegalArgumentException("Token desconhecido: " + t);
                }
            }

            while (!pilha.isEmpty()) {
                String t = pilha.pop();
                if (t.equals("(") || t.equals(")")) throw new IllegalArgumentException("Parênteses desbalanceados");
                saida.add(t);
            }
            return saida;
        }

        private static boolean ehEsquerdaAssociativo(String op) {
            return !op.equals("^");
        }

        private static double avaliarRPN(List<String> rpn) {
            Deque<Double> pilha = new ArrayDeque<>();
            for (String t : rpn) {
                if (ehNumero(t)) {
                    pilha.push(Double.parseDouble(t));
                } else if (OPERADORES.contains(t)) {
                    if (pilha.size() < 2) throw new IllegalArgumentException("Expressão inválida (operador sem operandos)");
                    double b = pilha.pop();
                    double a = pilha.pop();
                    switch (t) {
                        case "+": pilha.push(a + b); break;
                        case "-": pilha.push(a - b); break;
                        case "*": pilha.push(a * b); break;
                        case "/": pilha.push(a / b); break;
                        case "^": pilha.push(Math.pow(a, b)); break;
                        default: throw new IllegalArgumentException("Operador desconhecido: " + t);
                    }
                } else if (FUNCOES.containsKey(t)) {
                    if (pilha.isEmpty()) throw new IllegalArgumentException("Função sem argumento: " + t);
                    double a = pilha.pop();
                    pilha.push(FUNCOES.get(t).apply(a));
                } else {
                    throw new IllegalArgumentException("Token desconhecido no RPN: " + t);
                }
            }
            if (pilha.isEmpty()) throw new IllegalArgumentException("Expressão vazia");
            return pilha.pop();
        }

        private static boolean ehNumero(String s) {
            return s.matches("-?\\d+(\\.\\d+)?");
        }
    } // fim ExpressionEvaluator

    // ---- Cálculo de integral por soma de Riemann (ponto médio) ----
    public static double calcularIntegral(String funcao, double a, double b, double tolerancia) {
        if (a == b) return 0;
        if (a > b) return -calcularIntegral(funcao, b, a, tolerancia);

        int n = 1000;
        double resultadoAnterior = 0;
        double resultadoAtual = calcularRiemann(funcao, a, b, n);

        final int MAX_N = 1 << 20; // limite de subdivisões (≈1.048.576)
        while (Math.abs(resultadoAtual - resultadoAnterior) > tolerancia) {
            if (n >= MAX_N) throw new IllegalStateException("Não convergiu: limite máximo de subdivisões atingido (n=" + n + ").");
            n *= 2;
            resultadoAnterior = resultadoAtual;
            resultadoAtual = calcularRiemann(funcao, a, b, n);
        }

        return resultadoAtual;
    }

    private static double calcularRiemann(String funcao, double a, double b, int n) {
        double largura = (b - a) / n;
        double soma = 0;
        for (int i = 0; i < n; i++) {
            double x = a + (i + 0.5) * largura;
            double y;
            try {
                y = ExpressionEvaluator.avaliar(funcao, x);
            } catch (Exception e) {
                throw new IllegalArgumentException("Erro ao avaliar função em x = " + x + ": " + e.getMessage(), e);
            }
            soma += y * largura;
        }
        return soma;
    }

    private static void testarIntegral(String funcao, double a, double b, double tolerancia, double esperado) {
        try {
            double resultado = calcularIntegral(funcao, a, b, tolerancia);
            double erro = Math.abs(resultado - esperado);
            System.out.printf("∫%s dx [%.1f,%.1f] = %.6f (esperado: %.6f, erro: %.6f)%n",
                    funcao, a, b, resultado, esperado, erro);
        } catch (Exception e) {
            System.out.println("Erro no teste " + funcao + ": " + e.getMessage());
        }
    }

    // ---- main ----
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("=== CALCULADORA DE INTEGRAIS ===");
        System.out.println("Digite a função f(x) (use 'x' como variável):");
        System.out.println("Funções: sin, cos, tan, exp, log, sqrt, abs");
        System.out.println("Ex.: x^2 + 3*x - 5   |   sin(x)*cos(x)   |   exp(-x^2)");
        System.out.println("IMPORTANTE: use '*' para multiplicação explícita");

        String funcao = scanner.nextLine();

        System.out.println("Digite o limite inferior a:");
        double a = scanner.nextDouble();

        System.out.println("Digite o limite superior b:");
        double b = scanner.nextDouble();

        System.out.println("Digite a tolerância (ex: 0.0001):");
        double tolerancia = scanner.nextDouble();

        try {
            double resultado = calcularIntegral(funcao, a, b, tolerancia);
            System.out.printf("∫[%.4f, %.4f] %s dx ≈ %.8f%n", a, b, funcao, resultado);

            // testes rápidos
            System.out.println("\n=== TESTES ===");
            testarIntegral("x", 0, 1, 1e-4, 0.5);
            testarIntegral("x^2", 0, 1, 1e-4, 1.0 / 3.0);

        } catch (Exception e) {
            System.out.println("Erro: " + e.getMessage());
            e.printStackTrace();
        } finally {
            scanner.close();
        }
    }
}
